第二章和第三章是基础

# 第一章 简介
## 1.2 线程优势
发挥多处理器强大的能力
建模的简单性
异步事件的简化处理
gui响应跟灵敏

## 1.3 线程带来的风险

### 1.3.1 安全性问题
安全性：永远不发生糟糕的事情

### 1.3.2 活跃性问题
某件正确的事情最终会发生
死锁、饥饿、活锁

### 1.3.3 性能问题
希望事情尽快发生
频繁的上下文切换

## 1.4 线程无处不在
jvm jui timer

# 第二章 线程安全性

同步和锁

## 2.1 什么是线程安全性
当多个线程访问某个类时，这个类始终可以表现出正确的行为，那就称这个类是线程安全的。



无状态对象是线程安全的
## 2.2 原子性

并发编程中由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，：竞态条件
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32389139/1675587111553-d349db7b-8eb1-4d49-bd55-b4349a645b20.png#averageHue=%239a7134&clientId=u2ba2fa82-3937-4&from=paste&height=270&id=u91a07976&name=image.png&originHeight=270&originWidth=1140&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51978&status=done&style=none&taskId=u80a2bb30-44fa-439e-aebe-d316380681e&title=&width=1140)

### 2.2.1 竞态条件
最常见的竞态条件就是  先检查后执行
### 2.2.2 示例：延迟初始化中的竞态条件

通过原子类保证安全

## 2.3 加锁机制
### 2.3.1 内置锁
synchronized关键字
### 2.3.2 重入锁
可重入，获取
## 2.4 用锁来保护状态

## 2.5 活跃性与性能
通过缩小同步代码块范围，可以保证并发性和保证安全性

# 第3章 对象的共享
内存可见性：可以看到其他内存的修改；和线程安全性的主要区别是可见性仅需要看到，而安全性需要看到还有需要同时修改

## 3.1 可见性

















