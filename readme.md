找工作刷的题

##acm
    存放了acm模式的题，主要是牛客网刷的题

##leetcode
    主要是自己随便在leetcode上面刷的题

##leetcode101 
    主要是看leetcode101 c++版的书，然后按照书上的内容刷题

###c01 贪心算法
    c01 贪心算法
    每次操作都是局部最优的，从而使最
    后得到的结果是全局最优的。
    
    135. 分发糖果（分配问题）
        至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别
        排序
    
    435. 无重叠区间（区间问题）
    
    605. 种花问题
        采取什么样的贪心策略，可以种植最多的花朵呢？
    
    452. 用最少数量的箭引爆气球（区间问题）
        排序
    
    763. 划分字母区间
        为了满足你的贪心策略，是否需要一些预处理？
        注意在处理数组前，统计一遍信息（如频率、个数、第一次出现位置、最后一次出现位置等）可
         以使题目难度大幅降低。
        由于同一个字母只能出现在同一个片段，
        显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。
        因此需要遍历字符串，得到每个字母最后一次出现的下标位置
    
    122. 买卖股票的最佳时机 II
    
    406. 根据身高重建队列
        温馨提示，这道题可能同时需要排序和插入操作。
    
    665. 非递减数列
        需要仔细思考你的贪心策略在各种情况下，是否仍然是最优解。


###c03 双指针
    167. 两数之和 II - 输入有序数组
        （Two Sum）
        双指针或者 二分查找
    
    88. 合并两个有序数组
        （归并两个有序数组）

    142. 环形链表 II（快慢指针）
    
    76. 最小覆盖子串（滑动窗口）
    
    633. 平方数之和（Two Sum）
        Two Sum 题目的变形题之一
    
    680. 验证回文字符串 Ⅱ（Two Sum）
        Two Sum 题目的变形题之二。用了一下递归
    
    524. 通过删除字母匹配到字典里最长单词
        归并两个有序数组的变形题。
    
    340. 至多包含 K 个不同字符的最长子串
        滑动窗口 + 哈希表

###c04 二分查找
    69. x 的平方根（求开方）
    
    34. 在排序数组中查找元素的第一个和最后一个位置（查找区间）
    
    81. 搜索旋转排序数组 II（旋转数组查找数字）
    
    154. 寻找旋转排序数组中的最小值 II
         旋转数组的变形题之一。
    
    540. 有序数组中的单一元素
         在出现独立数之前和之后，奇偶位数的值发生了什么变化？
    
    4. 寻找两个正序数组的中位数
       比较难

###c05 排序算法
    快速排序（Quicksort）
    
    归并排序（Merge Sort）
    
    插入排序（Insertion Sort）
    
    冒泡排序（Bubble Sort）
    
    选择排序（Selection Sort）
    
    215. 数组中的第K个最大元素（快速选择）
         快速选择：适应与查找第k大的元素
    
    347. 前 K 个高频元素（桶排序）
         给定一个数组，求前k 个最频繁的数字
         hashmap + 优先队列
    
    451. 根据字符出现频率排序
         hashmap + 优先队列
    
    75. 颜色分类
        //(0, p1] == 0
        //(p1 , i] == 1
        //[p2 , len -1) == 2

###c06 一切皆可搜索
        用到不断便利的考虑 dfs
        看到最短考虑 bfs
        一般返回很多元素 就是用回溯算法
    
    
    
    695. 岛屿的最大面积（dfs）
         我们每次经过一块土地时，将这块土地的值置为 0
         每到一个岛屿加一
    
    547. 省份数量（dfs）
         计算联通图数量
    
    417. 太平洋大西洋水流问题（dfs 反向思考 从流水浅的地方进行递归）
    
    46. 全排列（常见）
        回溯
    
    79. 单词搜索（回溯）
    
    51. N 皇后
        使用三个集合 columns、diagonals1、diagonals2
        分别记录每一列以及两个方向的每条斜线上是否有皇后。
    
    
    934. 最短的桥（dfs + bfs）
         找到两个岛直接的最小距离，
         首先我们找到第一个岛，然后将第一个岛标记为2，并且将相邻的0放入队列中
         进行广度优先搜索，找到1即停止
    
    130. 被围绕的区域
         深度优先搜索
         对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；
         最后我们遍历这个矩阵，对于每一个字母：
         如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；
         如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。
    
    257. 二叉树的所有路径
         深度优先搜索
         思路与算法
         最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。
         如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。
         如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，
         将该路径加入到答案即可。
         如此，当遍历完整棵二叉树以后我们就得到了所有从根节点到叶子节点的路径。
         当然，深度优先搜索也可以使用非递归的方式实现，这里不再赘述。
    
    47. 全排列 II 返回没有重复的,比较麻烦
    
    40. 组合总和 II 返回没有重复的,比较麻烦 (都是用排序+限制条件)
    
    37. 解数独
        和n皇后类似， 设置3个二维数组来标记这个节点可以填什么数组
        进行回溯，每次是列加1，当列满了时候，行加一
    
    
    310. 最小高度树
         没做出了 超时（使用bfs算法，每个节点重新进行广度优先搜索）
         好的算法每次从度为1的节点进行便利 反向操作

###c07 章深入浅出动态规划
    
    ### 一维
    70. 爬楼梯
    
    198. 打家劫舍
    
    413. 等差数列划分
    
    ### 二维
    64. 最小路径和
        一般看到从某一个点到另一个点的题会先想到用dfs或者bfs来做
        但是这题限制了只能向下或者向右
        所以也可以使用dp来做，
        每次到了新的节点，我比较dp[i-1][j] 和dp[i][j-1]的最小值，加上当前节点
        就是从0，0出发，到第i,j坐标的最短路径
        然后返回dp[m][n] 即可
    
    542. 01 矩阵
         一般看到最近会想到bfs
         但是bfs复杂度太高，
         我们使用两次dp来做，分别从左上到右下
         和从右下到左上，相当于完成在四个方向上的查找
    
    221. 最大正方形
         dp[i][j] 表示满足题目条件的、以(i, j) 为右下角的正方形或者长方形的属性
         我们假设dp[i][j] = k*k，其充分条件为dp[i-1][j-1]、dp[i][j-1] 和dp[i-1][j] 的值必须
         都不小于k*k
    
    ### 分割问题
    279. 完全平方数
         分割问题，
         dp[n] 表示n至少需要几个完全平方数可以表示
         dp[n*n] = 1
         在本题中，位置i 只依赖i - k2 的位置，如i - 1、i - 4、i - 9 等等，才能满足完全平方分割
         的条件
    
    91. 解码方法
        dp[i] 表示
        如果第i个表示单数 dp[i] += dp[i-1]
        如果dp[i]与前一个合并 dp[i] += dp[i-2]
    
    139. 单词拆分
         类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分
         割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。注意对于位置0，需要初
         始化值为真
    
    ### 子序列问题
    300. 最长递增子序列
         dp[i] 可以表示以i 结尾的、最长子序列长度。对于每一个位置i，如果其之前的某
         个位置j 所对应的数字小于位置i 所对应的数字，则我们可以获得一个以i 结尾的、长度为dp[j]
         +1 的子序列。为了遍历所有情况，我们需要i 和j 进行两层循环，其时间复杂度为O¹n2º。
    
    1143. 最长公共子序列
          dp[i][j] 表示test1长度为i，text2长度为j的时候 他们的公共子序列的长度
          如果第 t1 的i he t2 的j 相等 dp[i][j] = dp[i-1][j-1] + 1；
          否则dp[i][j] = Math.max(dp[i][j-1] , dp[i-1][j])
    
    ### 背包问题
    416. 分割等和子集
         相当于是0-1背包问题
         遇到一个元素判断，是否取这个元素，
         直到最后背包内的最大值为sum/2
    
    474. 一和零
         感觉还是0-1背包问题，
         dp[k][i][j] 代表的 有i个0 和 j个1 时候 的最大值
         动态规划的思路是：物品一个一个尝试，容量一点一点尝试，每个物品分类讨论的标准是：选与不选。
    
    322. 零钱兑换
    
    ### 字符串编辑
    72. 编辑距离
        类似于题目1143，我们使用一个二维数组dp[i][j]，表示将第一个字符串到位置i 为止，和第
        二个字符串到位置j 为止，最多需要几步编辑。当第i 位和第j 位对应的字符相同时，dp[i][j] 等
        于dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是dp[i-1][j-1]+1，插入i 位置/删除j 位置
        的消耗是dp[i][j-1] + 1，插入j 位置/删除i 位置的消耗是dp[i-1][j] + 1。
    
    10. 正则表达式匹配
    
    ### 股票交易
    121. 买卖股票的最佳时机
    
    188. 买卖股票的最佳时机 IV
         使用动态规划来做
         使用两个数组一个为buy， buy[i] 标识第i次 买入股票的最大收入
         sell[j] 标识第j次 卖出股票的最大收入。
    
    309. 最佳买卖股票时机含冷冻期
    
    ### 练习
    213. 打家劫舍 II
         强盗抢劫题目的follow-up，如何处理环形数组呢？
         分为两个一个dp标识必须选第一个，一个dp表示不选第一个
    
    53. 最大子序和
        经典的一维动态规划题目，试着把一维空间优化为常量吧。
    
    343. 整数拆分
         分割类型题，先尝试用动态规划求解，再思考是否有更简单的解法。
    
    583. 两个字符串的删除操作
         最长公共子序列的变种题。
    
    376. 摆动序列
         最长递增子序列的变种题，同样的，尝试用二分进行加速。
    
    494. 目标和
         如果告诉你这道题是0-1 背包，你是否会有一些思路？
    
    714. 买卖股票的最佳时机含手续费
         建立状态机，股票交易类问题就会迎刃而解。
     
###mianshi
    代表面试刷的题