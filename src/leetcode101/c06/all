搜索 （dfs，回溯，bfs）
用到不断便利的考虑 dfs
看到最短考虑 bfs
一般返回很多元素 就是用回溯算法



695. 岛屿的最大面积（dfs）
我们每次经过一块土地时，将这块土地的值置为 0
每到一个岛屿加一

547. 省份数量（dfs）
计算联通图数量

417. 太平洋大西洋水流问题（dfs 反向思考 从流水浅的地方进行递归）

46. 全排列（常见）
回溯

79. 单词搜索（回溯）

51. N 皇后
使用三个集合 columns、diagonals1、diagonals2
分别记录每一列以及两个方向的每条斜线上是否有皇后。


934. 最短的桥（dfs + bfs）
找到两个岛直接的最小距离，
首先我们找到第一个岛，然后将第一个岛标记为2，并且将相邻的0放入队列中
进行广度优先搜索，找到1即停止

130. 被围绕的区域
深度优先搜索
对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；
最后我们遍历这个矩阵，对于每一个字母：
如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；
如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。

257. 二叉树的所有路径
深度优先搜索
思路与算法
最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。
如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。
如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。
如此，当遍历完整棵二叉树以后我们就得到了所有从根节点到叶子节点的路径。当然，深度优先搜索也可以使用非递归的方式实现，这里不再赘述。

47. 全排列 II 返回没有重复的,比较麻烦

40. 组合总和 II 返回没有重复的,比较麻烦 (都是用排序+限制条件)

37. 解数独
和n皇后类似， 设置3个二维数组来标记这个节点可以填什么数组
进行回溯，每次是列加1，当列满了时候，行加一


310. 最小高度树
没做出了 超时（使用bfs算法，每个节点重新进行广度优先搜索）
好的算法每次从度为1的节点进行便利 反向操作